from typing import Optional, Dict

from ._common import FileArg

def load(filename: FileArg, namehint: Optional[str] = "") -> None: ...
def unload() -> None: ...
def play(loops: int = 0, start: float = 0.0, fade_ms: int = 0) -> None: ...
def rewind() -> None: ...
def stop() -> None: ...
def pause() -> None: ...
def unpause() -> None: ...
def fadeout(time: int, /) -> None: ...
def set_volume(volume: float, /) -> None: ...
def get_volume() -> float: ...
def get_busy() -> bool: ...
def set_pos(pos: float, /) -> None: ...
def get_pos() -> int: ...
def queue(filename: FileArg, namehint: str = "", loops: int = 0) -> None: ...
def set_endevent(event_type: int, /) -> None: ...
def get_endevent() -> int: ...
def get_metadata(filename: Optional[FileArg] = None, namehint: str = "") -> Dict[str, str]: ...


# the queue "playing" status refer to the flag of changing to the next song automatically
# or not, not if some music is playing. stop, resume and get busy operate on that flag.
# stopping the queue won't stop the music it will only stop it from playing the next song
# if a song ends while it is paused resuming it will play the next song automatically
# by design
# changing the index inside the queue won't impact the current loop count but playing or
# restarting it does
# when the filenames are changed or the index is changed the music will change if the queue
# was playing. the index is independent from the currently playing music
# if 2 Queue instances are played at the same time, only the most recent one will receive
# endevents and play the next songs automatically. It will also stop the previously playing
# Queue
class Queue:
    def __init__(self, filenames: list[str|tuple[str, int]]|None = None) -> None: ...
    @property
    def filenames(self) -> list[str]: ...
    @filenames.setter
    def filenames(self, v: list[str|tuple[str, int]]): ...
    @property
    def index(self) -> int: ...
    @index.setter
    def index(self, v: int): ...
    
    def add(self, filename: str, loops: int = 0) -> None: ...
    def remove(self, filename: str) -> None: ...
    def pop(self, index: int) -> str: ...
    def get_busy(self) -> bool: ...
    def get_next(self) -> str: ...
    def play(self, loops: int = -1, fade_ms: int = 0, index: int = 0) -> None: ...
    def stop(self) -> None: ...
    def resume(self) -> None: ...
    def restart(self) -> None: ...
    def next(self) -> None: ...
    def previous(self) -> None: ...
